/*
 * Michael Masenheimer CSC 345 
 * Program #1: Somewhat Simplified Solitaire Encryption Algorithm: Twoâ€“Suit Variant
 * Dr. McCann, Dr. Lynam, Jesse Chen, Moyeen Uddin, due September 18
 * 
 * Description:
 *
 * This program was written to refresh my java skills. It is a play on a classic solitaire encryption/decryption
 * algorithm using keystreams generated by a half deck of cards. In terms of data structures, only fixed arrays
 * were used since all of the input and output data doesn't necessarily need to be changed. This program
 * uses what is called a "keystream" algorithm, which involves shifting the deck of cards around to generate custom
 * values used in the encryption/decription process for each character in the input and output.
 * 
 * Operations:
 * This program uses Java version 24, and the input is taken from the terminal in the form of "encryption/decryption.java messages.txt deck.txt"
 * 
 * As far as I know, all possible placements of jokers and valid decks are handled. Few bugs with
 * file ins and valid deck checking.
 */

/*
 * Class: Decrypt.java
 * Name: Michael Masenheimer
 * Package: Project 1 (No inheritence), relies on ConvertDeck.java and keystream.java
 * 
 * Purpose: This class represents a decryption algorithm to decrypt a previous encrypted message. It relies
 * on keystream values generated by keystream.java on the input deck. In essence, this class does the calculations
 * to decrypt based on those keystream values, also handling file errors and i/o.
 * 
 * There are no public constants and no public variables (fields) declared in this class.
 * All variables are declared as local variables inside methods.
 * 
 * Decrypt also has no explicitly defined constructors
 */


import java.io.File;
import java.io.FileNotFoundException;
import java.util.HashMap;
import java.util.Scanner;

public class Decrypt {

    /*
     * Method: decrypt
     * Purpose: Decrypts an encrypted message using the Solitaire cipher and prints the decrypted text.
     * Pre-condition: 
     *   - message contains the encrypted text.
     *   - deck contains integers representing a valid deck (1-28) for keystream generation.
     * Post-condition: The deck is modified according to keystream generation steps.
     * Return value: Returns the modified deck (primary effect is printing decrypted message).
     * Parameters:
     *   - message (in): String containing the encrypted message.
     *   - deck (in/out): Integer array representing the deck; modified by keystream operations.
    */

    public static Integer[] decrypt (String message, Integer[] deck) {

        HashMap<Character, Integer> map = new HashMap<>();

        for (char c = 'A'; c <= 'Z'; c++) {
            map.put(c, c - 'A' + 1);
        }
        // Map letters to their respective number in the alphabet

        String converted = "";

        for (int i = 0; i < message.length(); i++) {
            // Clean the input message to be only letters and be uppercase
            char ch = message.charAt(i);

            if (Character.isLetter(ch)) {
            converted += Character.toUpperCase(ch);

            }
        }

       Integer[] numbered = new Integer[converted.length()];
        for (int i = 0; i < converted.length(); i++) {
            // Convert letters to numbers
            numbered[i] = map.get(converted.charAt(i));
        }

        int numIterations = (numbered.length);
        Integer[] keyStreamValues = new Integer[numIterations];
        // Generate new array for the keystream values

        Integer[] finalResultArr = new Integer[keyStreamValues.length];
        int index = 0;
        while (index < numIterations) {
            // Generate keystream values based on the current item in the deck
            keyStreamValues[index] = keystream.findKeyStream(deck);

            index += 1;
        }

        for (int i = 0; i < keyStreamValues.length; i++) {
            // Subtract keystream to decrypt numbers

            if (numbered[i] <= keyStreamValues[i]) {
                numbered[i] += 26;
            }
            int tmp = numbered[i] - keyStreamValues[i];
            
            finalResultArr[i] = tmp;
        }

        StringBuilder finalResult = new StringBuilder();
        // Return string

        for (int num : finalResultArr) {
             // Convert numbers back to letters
            if (num >= 1 && num <= 26) {
                char c = (char) ('A' + num - 1);
                finalResult.append(c);
            }
        }

        System.out.println(finalResult);

        return deck;

    }

        /*
        * Method: main
        * Purpose: Reads a deck and encrypted messages from files, converts the deck, and decrypts each message.
        * Pre-condition: Files "messages.txt" and "test1.txt" exist and contain valid data.
        * Post-condition: All messages in "messages.txt" are decrypted and printed; scanners are closed.
        * Return value: None.
        * Parameters:
        *   - args (in): Command-line arguments (not used).
        */

        public static void main (String[] args) throws FileNotFoundException{
        File inputMessages = new File("messages.txt");
        File inputDeck = new File("test1.txt");

        Scanner messageScanner = new Scanner(inputMessages);
        Scanner deckScanner = new Scanner(inputDeck);

        String theDeck = deckScanner.nextLine();
        Integer[] convertedDeck = ConvertDeck.startConvert(theDeck);
        // Read and convert deck

        while (messageScanner.hasNextLine()) {
            // Decrypt each message line
            String curr = messageScanner.nextLine();

            decrypt(curr, convertedDeck);
        }

        messageScanner.close();
        deckScanner.close();
    
    }
}