/*
 * Michael Masenheimer CSC 345 
 * Program #1: Somewhat Simplified Solitaire Encryption Algorithm: Two–Suit Variant
 * Dr. McCann, Dr. Lynam, Jesse Chen, Moyeen Uddin, due September 18
 * 
 * Description:
 *
 * This program was written to refresh my Java skills. It is a play on a
 * classic solitaire encryption/decryption algorithm using keystreams
 * generated by a half deck of cards. In terms of data structures, only
 * fixed arrays were used since all of the input and output data doesn't
 * necessarily need to be changed. This program uses what is called a
 * "keystream" algorithm, which involves shifting the deck of cards around
 * to generate custom values used in the encryption/decryption process for
 * each character in the input and output.
 *
 * 
 * Operations:
 * 
 * This program uses Java version 24, and the input is taken from the 
 * terminal in the form of "encryption/decryption.java messages.txt deck.txt"
 * 
 * As far as I know, all possible placements of jokers and valid decks are handled. Few bugs with
 * file ins and valid deck checking.
 */


 /*
 * Class: Encrypt.java
 * Name: Michael Masenheimer
 * Package: Project 1 (No inheritence), relies on ConvertDeck.java and keystream.java
 * 
 * Purpose: This class represents a encryption algorithm to 
 * decrypt a previous encrypted message. 
 * It relies on keystream values generated by keystream.java on the 
 * input deck. In essence, this class does the calculations
 * to encrypt based on those keystream values, also handling file errors and i/o.
 * 
 * There are no public constants and no public variables (fields) 
 * declared in this class. All variables are declared as local variables inside methods.
 * 
 * Encrypt also has no explicitly defined constructors
 */

import java.io.File;
import java.io.FileNotFoundException;
import java.util.HashMap;
import java.util.Scanner;

public class Encrypt {

    /*
     * Method: encrypt
     * Purpose: Encrypts a message using the Solitaire cipher and prints the encrypted text.
     * Pre-condition: 
     *   - message contains plaintext letters.
     *   - deck contains integers representing a valid deck (1-28) for keystream generation.
     * Post-condition: The deck is modified according to keystream generation steps.
     * Return value: Returns the modified deck (primary effect is printing encrypted message).
     * Parameters:
     *   - message (in): String containing the plaintext message.
     *   - deck (in/out): Integer array representing the deck; modified by keystream operations.
    */

    public static Integer[] encrypt (String message, Integer[] deck) {

        HashMap<Character, Integer> map = new HashMap<>();

        for (char c = 'A'; c <= 'Z'; c++) {
            map.put(c, c - 'A' + 1);
        }
        // Map letters A-Z to 1-26

        String converted = "";
        for (int i = 0; i < message.length(); i++) {
            // Remove non-letter characters and convert to uppercase

            if (Character.isLetter(message.charAt(i))) {
                converted += Character.toUpperCase(message.charAt(i));
            }
        }

        int padding = (5 - (converted.length() % 5)) % 5;
        converted += "X".repeat(padding);
        // Pad message to multiple of 5 with 'X'

        Integer[] numbered = new Integer[converted.length()];
        for (int i = 0; i < converted.length(); i++) {
            // Convert letters to numbers
            numbered[i] = map.get(converted.charAt(i));
        }


        int numIterations = (numbered.length);
        Integer[] keyStreamValues = new Integer[numIterations];


        int index = 0;
        Integer[] finalResultArr = new Integer[keyStreamValues.length];
        while (index < numIterations) {
            // Generate keystream values
            keyStreamValues[index] = keystream.findKeyStream(deck);
            index += 1;
        }


        for (int i = 0; i < keyStreamValues.length; i++) {
            // Add keystream values
            int temp = numbered[i] + keyStreamValues[i];

            if (temp > 26) {
                temp -= 26;
            }
            finalResultArr[i] = temp;
        }
        StringBuilder finalResult = new StringBuilder();

        for (int num : finalResultArr) {
             // Convert back to letters
            if (num >= 1 && num <= 26) {
                char c = (char) ('A' + num - 1);
                finalResult.append(c);
            }
        }
        System.out.println(finalResult);
        return deck;
    }

    /*
     * Method: isValidDeck
     * Purpose: Checks whether a given deck is valid for encryption.
     * Pre-condition: The deck array is not null.
     * Post-condition: Returns true if the deck contains exactly 28 cards, with values 1–28, each exactly once.
     * Return value: boolean – true if deck is valid, false otherwise.
     * Parameters:
     *   - deck (in): Array of Integer representing a deck of cards.
    */
    private static boolean isValidDeck(Integer[] deck) {
        // Must have 28 cards
        if (deck.length != 28) {
            return false;
        }

        // All cards 1-28 exactly once
        boolean[] found = new boolean[29]; 
        // index 1-28
        for (int card : deck) {
            if (card < 1 || card > 28) return false;
            if (found[card]) return false; 
            // There is a duplicate card
            found[card] = true;
        }
        return true;
    }

    /*
     * Method: main
     * Purpose: Reads messages and a deck from files, validates the deck, and encrypts each message.
     * Pre-condition: Files specified as command-line arguments exist and contain valid data.
     * Post-condition: Messages are encrypted and printed to output; scanners are closed.
     * Return value: None
     * Parameters:
     *   - args (in): Command-line arguments: args[0] = messages file, args[1] = deck file.
    */
    public static void main(String[] args) {

        File inputDeck = new File(args[0]);
        File inputMessages = new File(args[1]);

        // Check if files exist
        if (!inputMessages.exists()) {
            System.out.println("messages.txt does not exist.");
            return;
        }
        if (!inputDeck.exists()) {
            System.out.println("deck does not exist.");
            return;
        }

        try {
            Scanner messageScanner = new Scanner(inputMessages);
            Scanner deckScanner = new Scanner(inputDeck);

            // Read and convert deck
            if (!deckScanner.hasNextLine()) {
                System.out.println("Deck file is empty.");
                deckScanner.close();
                messageScanner.close();
                return;
            }

            String theDeck = deckScanner.nextLine();
            Integer[] convertedDeck = ConvertDeck.startConvert(theDeck);

            // Validate deck
            if (!isValidDeck(convertedDeck)) {
                System.out.println("Deck is invalid.");
                deckScanner.close();
                messageScanner.close();
                return;
            }

            // Encrypt each message line
            while (messageScanner.hasNextLine()) {
                String curr = messageScanner.nextLine();
                encrypt(curr, convertedDeck);
            }

            messageScanner.close();
            deckScanner.close();

        } catch (FileNotFoundException e) {
            System.out.println("One of the files could not be found.");

        } catch (Exception e) {
            System.out.println("An unexpected error occurred: " + e.getMessage());
        }
    }

}